/*
* generated by Xtext
*/
package net.modelbased.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.ocl.examples.xtext.oclinecore.services.OCLinEcoreGrammarAccess;
import org.eclipse.ocl.examples.xtext.essentialocl.services.EssentialOCLGrammarAccess;

@Singleton
public class ConstraintMLGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class MyRootCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MyRootCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRootPackageCSAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cModuleKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_1_1_0 = (RuleCall)cNameAssignment_1_1.eContents().get(0);
		private final Assignment cOwnedLibraryAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOwnedLibraryLibraryCSParserRuleCall_2_0 = (RuleCall)cOwnedLibraryAssignment_2.eContents().get(0);
		private final Assignment cOwnedImportAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOwnedImportImportCSParserRuleCall_3_0 = (RuleCall)cOwnedImportAssignment_3.eContents().get(0);
		private final Assignment cOwnedNestedPackageAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cOwnedNestedPackageMyPackageParserRuleCall_4_0 = (RuleCall)cOwnedNestedPackageAssignment_4.eContents().get(0);
		
		//MyRootCS returns base::RootPackageCS:
		//	{base::RootPackageCS} ("module" name=UnrestrictedName)? ownedLibrary+=LibraryCS* ownedImport+=ImportCS*
		//	ownedNestedPackage+=MyPackage*;
		public ParserRule getRule() { return rule; }

		//{base::RootPackageCS} ("module" name=UnrestrictedName)? ownedLibrary+=LibraryCS* ownedImport+=ImportCS*
		//ownedNestedPackage+=MyPackage*
		public Group getGroup() { return cGroup; }

		//{base::RootPackageCS}
		public Action getRootPackageCSAction_0() { return cRootPackageCSAction_0; }

		//("module" name=UnrestrictedName)?
		public Group getGroup_1() { return cGroup_1; }

		//"module"
		public Keyword getModuleKeyword_1_0() { return cModuleKeyword_1_0; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_1_1_0() { return cNameUnrestrictedNameParserRuleCall_1_1_0; }

		//ownedLibrary+=LibraryCS*
		public Assignment getOwnedLibraryAssignment_2() { return cOwnedLibraryAssignment_2; }

		//LibraryCS
		public RuleCall getOwnedLibraryLibraryCSParserRuleCall_2_0() { return cOwnedLibraryLibraryCSParserRuleCall_2_0; }

		//ownedImport+=ImportCS*
		public Assignment getOwnedImportAssignment_3() { return cOwnedImportAssignment_3; }

		//ImportCS
		public RuleCall getOwnedImportImportCSParserRuleCall_3_0() { return cOwnedImportImportCSParserRuleCall_3_0; }

		//ownedNestedPackage+=MyPackage*
		public Assignment getOwnedNestedPackageAssignment_4() { return cOwnedNestedPackageAssignment_4; }

		//MyPackage
		public RuleCall getOwnedNestedPackageMyPackageParserRuleCall_4_0() { return cOwnedNestedPackageMyPackageParserRuleCall_4_0; }
	}

	public class MyPackageElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MyPackage");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPackageKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cNsPrefixAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cNsPrefixUnrestrictedNameParserRuleCall_2_1_0 = (RuleCall)cNsPrefixAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cEqualsSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cNsURIAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cNsURIURIParserRuleCall_3_1_0 = (RuleCall)cNsURIAssignment_3_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cOwnedTypeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cOwnedTypeMyClassCSParserRuleCall_5_0 = (RuleCall)cOwnedTypeAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//MyPackage returns base::PackageCS:
		//	"package" name=UnrestrictedName (":" nsPrefix=UnrestrictedName)? ("=" nsURI=URI)? "{" ownedType+=MyClassCS* "}";
		public ParserRule getRule() { return rule; }

		//"package" name=UnrestrictedName (":" nsPrefix=UnrestrictedName)? ("=" nsURI=URI)? "{" ownedType+=MyClassCS* "}"
		public Group getGroup() { return cGroup; }

		//"package"
		public Keyword getPackageKeyword_0() { return cPackageKeyword_0; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_1_0() { return cNameUnrestrictedNameParserRuleCall_1_0; }

		//(":" nsPrefix=UnrestrictedName)?
		public Group getGroup_2() { return cGroup_2; }

		//":"
		public Keyword getColonKeyword_2_0() { return cColonKeyword_2_0; }

		//nsPrefix=UnrestrictedName
		public Assignment getNsPrefixAssignment_2_1() { return cNsPrefixAssignment_2_1; }

		//UnrestrictedName
		public RuleCall getNsPrefixUnrestrictedNameParserRuleCall_2_1_0() { return cNsPrefixUnrestrictedNameParserRuleCall_2_1_0; }

		//("=" nsURI=URI)?
		public Group getGroup_3() { return cGroup_3; }

		//"="
		public Keyword getEqualsSignKeyword_3_0() { return cEqualsSignKeyword_3_0; }

		//nsURI=URI
		public Assignment getNsURIAssignment_3_1() { return cNsURIAssignment_3_1; }

		//URI
		public RuleCall getNsURIURIParserRuleCall_3_1_0() { return cNsURIURIParserRuleCall_3_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }

		//ownedType+=MyClassCS*
		public Assignment getOwnedTypeAssignment_5() { return cOwnedTypeAssignment_5; }

		//MyClassCS
		public RuleCall getOwnedTypeMyClassCSParserRuleCall_5_0() { return cOwnedTypeMyClassCSParserRuleCall_5_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class MyClassCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MyClassCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cClassKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOwnedPropertyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOwnedPropertyMyPropertyParserRuleCall_3_0 = (RuleCall)cOwnedPropertyAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cConstraintKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cOwnedConstraintAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cOwnedConstraintMyConstraintPrefixParserRuleCall_4_1_0 = (RuleCall)cOwnedConstraintAssignment_4_1.eContents().get(0);
		private final Assignment cOwnedConstraintAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cOwnedConstraintMyConstraintParserRuleCall_4_2_0 = (RuleCall)cOwnedConstraintAssignment_4_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//MyClassCS returns base::ClassCS:
		//	"class" name=UnrestrictedName "{" ownedProperty+=MyProperty* ("constraint" ownedConstraint+=MyConstraintPrefix?
		//	ownedConstraint+=MyConstraint)* //(ownedConstraint += InvariantConstraintCS)*
		//	"}";
		public ParserRule getRule() { return rule; }

		//"class" name=UnrestrictedName "{" ownedProperty+=MyProperty* ("constraint" ownedConstraint+=MyConstraintPrefix?
		//ownedConstraint+=MyConstraint)* //(ownedConstraint += InvariantConstraintCS)*
		//"}"
		public Group getGroup() { return cGroup; }

		//"class"
		public Keyword getClassKeyword_0() { return cClassKeyword_0; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_1_0() { return cNameUnrestrictedNameParserRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//ownedProperty+=MyProperty*
		public Assignment getOwnedPropertyAssignment_3() { return cOwnedPropertyAssignment_3; }

		//MyProperty
		public RuleCall getOwnedPropertyMyPropertyParserRuleCall_3_0() { return cOwnedPropertyMyPropertyParserRuleCall_3_0; }

		//("constraint" ownedConstraint+=MyConstraintPrefix? ownedConstraint+=MyConstraint)*
		public Group getGroup_4() { return cGroup_4; }

		//"constraint"
		public Keyword getConstraintKeyword_4_0() { return cConstraintKeyword_4_0; }

		//ownedConstraint+=MyConstraintPrefix?
		public Assignment getOwnedConstraintAssignment_4_1() { return cOwnedConstraintAssignment_4_1; }

		//MyConstraintPrefix
		public RuleCall getOwnedConstraintMyConstraintPrefixParserRuleCall_4_1_0() { return cOwnedConstraintMyConstraintPrefixParserRuleCall_4_1_0; }

		//ownedConstraint+=MyConstraint
		public Assignment getOwnedConstraintAssignment_4_2() { return cOwnedConstraintAssignment_4_2; }

		//MyConstraint
		public RuleCall getOwnedConstraintMyConstraintParserRuleCall_4_2_0() { return cOwnedConstraintMyConstraintParserRuleCall_4_2_0; }

		////(ownedConstraint += InvariantConstraintCS)*
		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class MyPropertyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MyProperty");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMyAttributeCSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMyReferenceParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//MyProperty returns base::StructuralFeatureCS:
		//	MyAttributeCS | MyReference;
		public ParserRule getRule() { return rule; }

		//MyAttributeCS | MyReference
		public Alternatives getAlternatives() { return cAlternatives; }

		//MyAttributeCS
		public RuleCall getMyAttributeCSParserRuleCall_0() { return cMyAttributeCSParserRuleCall_0; }

		//MyReference
		public RuleCall getMyReferenceParserRuleCall_1() { return cMyReferenceParserRuleCall_1; }
	}

	public class MyReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MyReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cRefKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Assignment cQualifierAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final Keyword cQualifierContainsKeyword_0_1_0 = (Keyword)cQualifierAssignment_0_1.eContents().get(0);
		private final Assignment cOwnedTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOwnedTypeTypedMultiplicityRefCSParserRuleCall_1_0 = (RuleCall)cOwnedTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cOppositeKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cOppositeAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cOppositePropertyCrossReference_3_1_0 = (CrossReference)cOppositeAssignment_3_1.eContents().get(0);
		private final RuleCall cOppositePropertyUnrestrictedNameParserRuleCall_3_1_0_1 = (RuleCall)cOppositePropertyCrossReference_3_1_0.eContents().get(1);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Assignment cOwnedAnnotationAssignment_4_0 = (Assignment)cAlternatives_4.eContents().get(0);
		private final RuleCall cOwnedAnnotationMyPropertyDecoAnnotationParserRuleCall_4_0_0 = (RuleCall)cOwnedAnnotationAssignment_4_0.eContents().get(0);
		private final Group cGroup_4_1 = (Group)cAlternatives_4.eContents().get(1);
		private final Keyword cColonKeyword_4_1_0 = (Keyword)cGroup_4_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_4_1_1 = (Keyword)cGroup_4_1.eContents().get(1);
		private final Assignment cQualifierAssignment_4_1_2 = (Assignment)cGroup_4_1.eContents().get(2);
		private final Keyword cQualifierDerivedKeyword_4_1_2_0 = (Keyword)cQualifierAssignment_4_1_2.eContents().get(0);
		private final Assignment cOwnedDefaultExpressionAssignment_4_1_3 = (Assignment)cGroup_4_1.eContents().get(3);
		private final RuleCall cOwnedDefaultExpressionSpecificationCSParserRuleCall_4_1_3_0 = (RuleCall)cOwnedDefaultExpressionAssignment_4_1_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4_1_4 = (Keyword)cGroup_4_1.eContents().get(4);
		
		//MyReference returns base::ReferenceCS:
		//	("ref" | qualifier+="contains") ownedType=TypedMultiplicityRefCS name=UnrestrictedName ("opposite"
		//	opposite=[pivot::Property|UnrestrictedName])? (ownedAnnotation+=MyPropertyDecoAnnotation | ":" "{"
		//	qualifier+="derived" ownedDefaultExpression+=SpecificationCS "}")?;
		public ParserRule getRule() { return rule; }

		//("ref" | qualifier+="contains") ownedType=TypedMultiplicityRefCS name=UnrestrictedName ("opposite"
		//opposite=[pivot::Property|UnrestrictedName])? (ownedAnnotation+=MyPropertyDecoAnnotation | ":" "{"
		//qualifier+="derived" ownedDefaultExpression+=SpecificationCS "}")?
		public Group getGroup() { return cGroup; }

		//"ref" | qualifier+="contains"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"ref"
		public Keyword getRefKeyword_0_0() { return cRefKeyword_0_0; }

		//qualifier+="contains"
		public Assignment getQualifierAssignment_0_1() { return cQualifierAssignment_0_1; }

		//"contains"
		public Keyword getQualifierContainsKeyword_0_1_0() { return cQualifierContainsKeyword_0_1_0; }

		//ownedType=TypedMultiplicityRefCS
		public Assignment getOwnedTypeAssignment_1() { return cOwnedTypeAssignment_1; }

		//TypedMultiplicityRefCS
		public RuleCall getOwnedTypeTypedMultiplicityRefCSParserRuleCall_1_0() { return cOwnedTypeTypedMultiplicityRefCSParserRuleCall_1_0; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_2_0() { return cNameUnrestrictedNameParserRuleCall_2_0; }

		//("opposite" opposite=[pivot::Property|UnrestrictedName])?
		public Group getGroup_3() { return cGroup_3; }

		//"opposite"
		public Keyword getOppositeKeyword_3_0() { return cOppositeKeyword_3_0; }

		//opposite=[pivot::Property|UnrestrictedName]
		public Assignment getOppositeAssignment_3_1() { return cOppositeAssignment_3_1; }

		//[pivot::Property|UnrestrictedName]
		public CrossReference getOppositePropertyCrossReference_3_1_0() { return cOppositePropertyCrossReference_3_1_0; }

		//UnrestrictedName
		public RuleCall getOppositePropertyUnrestrictedNameParserRuleCall_3_1_0_1() { return cOppositePropertyUnrestrictedNameParserRuleCall_3_1_0_1; }

		//(ownedAnnotation+=MyPropertyDecoAnnotation | ":" "{" qualifier+="derived" ownedDefaultExpression+=SpecificationCS "}")?
		public Alternatives getAlternatives_4() { return cAlternatives_4; }

		//ownedAnnotation+=MyPropertyDecoAnnotation
		public Assignment getOwnedAnnotationAssignment_4_0() { return cOwnedAnnotationAssignment_4_0; }

		//MyPropertyDecoAnnotation
		public RuleCall getOwnedAnnotationMyPropertyDecoAnnotationParserRuleCall_4_0_0() { return cOwnedAnnotationMyPropertyDecoAnnotationParserRuleCall_4_0_0; }

		//":" "{" qualifier+="derived" ownedDefaultExpression+=SpecificationCS "}"
		public Group getGroup_4_1() { return cGroup_4_1; }

		//":"
		public Keyword getColonKeyword_4_1_0() { return cColonKeyword_4_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4_1_1() { return cLeftCurlyBracketKeyword_4_1_1; }

		//qualifier+="derived"
		public Assignment getQualifierAssignment_4_1_2() { return cQualifierAssignment_4_1_2; }

		//"derived"
		public Keyword getQualifierDerivedKeyword_4_1_2_0() { return cQualifierDerivedKeyword_4_1_2_0; }

		//ownedDefaultExpression+=SpecificationCS
		public Assignment getOwnedDefaultExpressionAssignment_4_1_3() { return cOwnedDefaultExpressionAssignment_4_1_3; }

		//SpecificationCS
		public RuleCall getOwnedDefaultExpressionSpecificationCSParserRuleCall_4_1_3_0() { return cOwnedDefaultExpressionSpecificationCSParserRuleCall_4_1_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4_1_4() { return cRightCurlyBracketKeyword_4_1_4; }
	}

	public class MyAttributeCSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MyAttributeCS");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cOwnedAnnotationAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cOwnedAnnotationMyConfigParserRuleCall_0_0_0 = (RuleCall)cOwnedAnnotationAssignment_0_0.eContents().get(0);
		private final Assignment cQualifierAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final Keyword cQualifierIdKeyword_0_1_0 = (Keyword)cQualifierAssignment_0_1.eContents().get(0);
		private final Assignment cOwnedTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOwnedTypeTypedMultiplicityRefCSParserRuleCall_1_0 = (RuleCall)cOwnedTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Assignment cOwnedAnnotationAssignment_3_0 = (Assignment)cAlternatives_3.eContents().get(0);
		private final RuleCall cOwnedAnnotationMyPropertyDecoAnnotationParserRuleCall_3_0_0 = (RuleCall)cOwnedAnnotationAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cAlternatives_3.eContents().get(1);
		private final Keyword cColonKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3_1_1 = (Keyword)cGroup_3_1.eContents().get(1);
		private final Assignment cQualifierAssignment_3_1_2 = (Assignment)cGroup_3_1.eContents().get(2);
		private final Keyword cQualifierDerivedKeyword_3_1_2_0 = (Keyword)cQualifierAssignment_3_1_2.eContents().get(0);
		private final Assignment cOwnedDefaultExpressionAssignment_3_1_3 = (Assignment)cGroup_3_1.eContents().get(3);
		private final RuleCall cOwnedDefaultExpressionSpecificationCSParserRuleCall_3_1_3_0 = (RuleCall)cOwnedDefaultExpressionAssignment_3_1_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3_1_4 = (Keyword)cGroup_3_1.eContents().get(4);
		
		//MyAttributeCS returns base::AttributeCS:
		//	(ownedAnnotation+=MyConfig | qualifier+="id")? ownedType=TypedMultiplicityRefCS name=UnrestrictedName
		//	(ownedAnnotation+=MyPropertyDecoAnnotation | ":" "{" qualifier+="derived" ownedDefaultExpression+=SpecificationCS
		//	"}")?;
		public ParserRule getRule() { return rule; }

		//(ownedAnnotation+=MyConfig | qualifier+="id")? ownedType=TypedMultiplicityRefCS name=UnrestrictedName
		//(ownedAnnotation+=MyPropertyDecoAnnotation | ":" "{" qualifier+="derived" ownedDefaultExpression+=SpecificationCS
		//"}")?
		public Group getGroup() { return cGroup; }

		//(ownedAnnotation+=MyConfig | qualifier+="id")?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//ownedAnnotation+=MyConfig
		public Assignment getOwnedAnnotationAssignment_0_0() { return cOwnedAnnotationAssignment_0_0; }

		//MyConfig
		public RuleCall getOwnedAnnotationMyConfigParserRuleCall_0_0_0() { return cOwnedAnnotationMyConfigParserRuleCall_0_0_0; }

		//qualifier+="id"
		public Assignment getQualifierAssignment_0_1() { return cQualifierAssignment_0_1; }

		//"id"
		public Keyword getQualifierIdKeyword_0_1_0() { return cQualifierIdKeyword_0_1_0; }

		//ownedType=TypedMultiplicityRefCS
		public Assignment getOwnedTypeAssignment_1() { return cOwnedTypeAssignment_1; }

		//TypedMultiplicityRefCS
		public RuleCall getOwnedTypeTypedMultiplicityRefCSParserRuleCall_1_0() { return cOwnedTypeTypedMultiplicityRefCSParserRuleCall_1_0; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_2_0() { return cNameUnrestrictedNameParserRuleCall_2_0; }

		//(ownedAnnotation+=MyPropertyDecoAnnotation | ":" "{" qualifier+="derived" ownedDefaultExpression+=SpecificationCS "}")?
		public Alternatives getAlternatives_3() { return cAlternatives_3; }

		//ownedAnnotation+=MyPropertyDecoAnnotation
		public Assignment getOwnedAnnotationAssignment_3_0() { return cOwnedAnnotationAssignment_3_0; }

		//MyPropertyDecoAnnotation
		public RuleCall getOwnedAnnotationMyPropertyDecoAnnotationParserRuleCall_3_0_0() { return cOwnedAnnotationMyPropertyDecoAnnotationParserRuleCall_3_0_0; }

		//":" "{" qualifier+="derived" ownedDefaultExpression+=SpecificationCS "}"
		public Group getGroup_3_1() { return cGroup_3_1; }

		//":"
		public Keyword getColonKeyword_3_1_0() { return cColonKeyword_3_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3_1_1() { return cLeftCurlyBracketKeyword_3_1_1; }

		//qualifier+="derived"
		public Assignment getQualifierAssignment_3_1_2() { return cQualifierAssignment_3_1_2; }

		//"derived"
		public Keyword getQualifierDerivedKeyword_3_1_2_0() { return cQualifierDerivedKeyword_3_1_2_0; }

		//ownedDefaultExpression+=SpecificationCS
		public Assignment getOwnedDefaultExpressionAssignment_3_1_3() { return cOwnedDefaultExpressionAssignment_3_1_3; }

		//SpecificationCS
		public RuleCall getOwnedDefaultExpressionSpecificationCSParserRuleCall_3_1_3_0() { return cOwnedDefaultExpressionSpecificationCSParserRuleCall_3_1_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3_1_4() { return cRightCurlyBracketKeyword_3_1_4; }
	}

	public class MyPropertyDecoAnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MyPropertyDecoAnnotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOwnedDetailAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOwnedDetailMyDomainParserRuleCall_2_0 = (RuleCall)cOwnedDetailAssignment_2.eContents().get(0);
		private final Assignment cOwnedDetailAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOwnedDetailMyResistanceParserRuleCall_3_0 = (RuleCall)cOwnedDetailAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//MyPropertyDecoAnnotation returns base::AnnotationCS:
		//	":" "{" ownedDetail+=MyDomain? ownedDetail+=MyResistance? //(ownedDetail += MyDerivation)?
		//	"}";
		public ParserRule getRule() { return rule; }

		//":" "{" ownedDetail+=MyDomain? ownedDetail+=MyResistance? //(ownedDetail += MyDerivation)?
		//"}"
		public Group getGroup() { return cGroup; }

		//":"
		public Keyword getColonKeyword_0() { return cColonKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//ownedDetail+=MyDomain?
		public Assignment getOwnedDetailAssignment_2() { return cOwnedDetailAssignment_2; }

		//MyDomain
		public RuleCall getOwnedDetailMyDomainParserRuleCall_2_0() { return cOwnedDetailMyDomainParserRuleCall_2_0; }

		//ownedDetail+=MyResistance?
		public Assignment getOwnedDetailAssignment_3() { return cOwnedDetailAssignment_3; }

		//MyResistance
		public RuleCall getOwnedDetailMyResistanceParserRuleCall_3_0() { return cOwnedDetailMyResistanceParserRuleCall_3_0; }

		////(ownedDetail += MyDerivation)?
		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class MyDerivationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MyDerivation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameDerivationKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprSpecificationCSParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//MyDerivation returns ext::ExpDetail:
		//	name="derivation" "=" expr+=SpecificationCS;
		public ParserRule getRule() { return rule; }

		//name="derivation" "=" expr+=SpecificationCS
		public Group getGroup() { return cGroup; }

		//name="derivation"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"derivation"
		public Keyword getNameDerivationKeyword_0_0() { return cNameDerivationKeyword_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//expr+=SpecificationCS
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//SpecificationCS
		public RuleCall getExprSpecificationCSParserRuleCall_2_0() { return cExprSpecificationCSParserRuleCall_2_0; }
	}

	public class MyResistanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MyResistance");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameResistanceKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprSpecificationCSParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//MyResistance returns ext::ExpDetail:
		//	name="resistance" "=" expr+=SpecificationCS;
		public ParserRule getRule() { return rule; }

		//name="resistance" "=" expr+=SpecificationCS
		public Group getGroup() { return cGroup; }

		//name="resistance"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"resistance"
		public Keyword getNameResistanceKeyword_0_0() { return cNameResistanceKeyword_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//expr+=SpecificationCS
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//SpecificationCS
		public RuleCall getExprSpecificationCSParserRuleCall_2_0() { return cExprSpecificationCSParserRuleCall_2_0; }
	}

	public class MyDomainElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MyDomain");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameDomainKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExprAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExprSpecificationCSParserRuleCall_2_0 = (RuleCall)cExprAssignment_2.eContents().get(0);
		
		//MyDomain returns ext::ExpDetail:
		//	name="domain" "=" expr+=SpecificationCS;
		public ParserRule getRule() { return rule; }

		//name="domain" "=" expr+=SpecificationCS
		public Group getGroup() { return cGroup; }

		//name="domain"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//"domain"
		public Keyword getNameDomainKeyword_0_0() { return cNameDomainKeyword_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//expr+=SpecificationCS
		public Assignment getExprAssignment_2() { return cExprAssignment_2; }

		//SpecificationCS
		public RuleCall getExprSpecificationCSParserRuleCall_2_0() { return cExprSpecificationCSParserRuleCall_2_0; }
	}

	public class MyConfigElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MyConfig");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAnnotationCSAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cNameConfigKeyword_1_0 = (Keyword)cNameAssignment_1.eContents().get(0);
		
		//MyConfig returns base::AnnotationCS:
		//	{base::AnnotationCS} name="config";
		public ParserRule getRule() { return rule; }

		//{base::AnnotationCS} name="config"
		public Group getGroup() { return cGroup; }

		//{base::AnnotationCS}
		public Action getAnnotationCSAction_0() { return cAnnotationCSAction_0; }

		//name="config"
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//"config"
		public Keyword getNameConfigKeyword_1_0() { return cNameConfigKeyword_1_0; }
	}

	public class MyConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MyConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameUnrestrictedNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSpecificationAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSpecificationSpecificationCSParserRuleCall_2_0 = (RuleCall)cSpecificationAssignment_2.eContents().get(0);
		
		//MyConstraint returns base::ConstraintCS:
		//	name=UnrestrictedName ":" specification=SpecificationCS;
		public ParserRule getRule() { return rule; }

		//name=UnrestrictedName ":" specification=SpecificationCS
		public Group getGroup() { return cGroup; }

		//name=UnrestrictedName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//UnrestrictedName
		public RuleCall getNameUnrestrictedNameParserRuleCall_0_0() { return cNameUnrestrictedNameParserRuleCall_0_0; }

		//":"
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//specification=SpecificationCS
		public Assignment getSpecificationAssignment_2() { return cSpecificationAssignment_2; }

		//SpecificationCS
		public RuleCall getSpecificationSpecificationCSParserRuleCall_2_0() { return cSpecificationSpecificationCSParserRuleCall_2_0; }
	}

	public class MyConstraintPrefixElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MyConstraintPrefix");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMyConstraintHardParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMyConstraintPriorityParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//MyConstraintPrefix returns base::ConstraintCS:
		//	MyConstraintHard | MyConstraintPriority;
		public ParserRule getRule() { return rule; }

		//MyConstraintHard | MyConstraintPriority
		public Alternatives getAlternatives() { return cAlternatives; }

		//MyConstraintHard
		public RuleCall getMyConstraintHardParserRuleCall_0() { return cMyConstraintHardParserRuleCall_0; }

		//MyConstraintPriority
		public RuleCall getMyConstraintPriorityParserRuleCall_1() { return cMyConstraintPriorityParserRuleCall_1; }
	}

	public class MyConstraintHardElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MyConstraintHard");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cNameHardKeyword_1_0 = (Keyword)cNameAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//MyConstraintHard returns base::ConstraintCS:
		//	"(" name="hard" ")";
		public ParserRule getRule() { return rule; }

		//"(" name="hard" ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//name="hard"
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//"hard"
		public Keyword getNameHardKeyword_1_0() { return cNameHardKeyword_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class MyConstraintPriorityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MyConstraintPriority");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cNamePriorityKeyword_1_0 = (Keyword)cNameAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cSpecificationAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSpecificationSpecificationCSParserRuleCall_3_0 = (RuleCall)cSpecificationAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//MyConstraintPriority returns base::ConstraintCS:
		//	"(" name="priority" "=" specification=SpecificationCS ")";
		public ParserRule getRule() { return rule; }

		//"(" name="priority" "=" specification=SpecificationCS ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//name="priority"
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//"priority"
		public Keyword getNamePriorityKeyword_1_0() { return cNamePriorityKeyword_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//specification=SpecificationCS
		public Assignment getSpecificationAssignment_3() { return cSpecificationAssignment_3; }

		//SpecificationCS
		public RuleCall getSpecificationSpecificationCSParserRuleCall_3_0() { return cSpecificationSpecificationCSParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	
	
	private MyRootCSElements pMyRootCS;
	private MyPackageElements pMyPackage;
	private MyClassCSElements pMyClassCS;
	private MyPropertyElements pMyProperty;
	private MyReferenceElements pMyReference;
	private MyAttributeCSElements pMyAttributeCS;
	private MyPropertyDecoAnnotationElements pMyPropertyDecoAnnotation;
	private MyDerivationElements pMyDerivation;
	private MyResistanceElements pMyResistance;
	private MyDomainElements pMyDomain;
	private MyConfigElements pMyConfig;
	private MyConstraintElements pMyConstraint;
	private MyConstraintPrefixElements pMyConstraintPrefix;
	private MyConstraintHardElements pMyConstraintHard;
	private MyConstraintPriorityElements pMyConstraintPriority;
	
	private final Grammar grammar;

	private OCLinEcoreGrammarAccess gaOCLinEcore;

	@Inject
	public ConstraintMLGrammarAccess(GrammarProvider grammarProvider,
		OCLinEcoreGrammarAccess gaOCLinEcore) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaOCLinEcore = gaOCLinEcore;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("net.modelbased.ConstraintML".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public OCLinEcoreGrammarAccess getOCLinEcoreGrammarAccess() {
		return gaOCLinEcore;
	}

	
	//MyRootCS returns base::RootPackageCS:
	//	{base::RootPackageCS} ("module" name=UnrestrictedName)? ownedLibrary+=LibraryCS* ownedImport+=ImportCS*
	//	ownedNestedPackage+=MyPackage*;
	public MyRootCSElements getMyRootCSAccess() {
		return (pMyRootCS != null) ? pMyRootCS : (pMyRootCS = new MyRootCSElements());
	}
	
	public ParserRule getMyRootCSRule() {
		return getMyRootCSAccess().getRule();
	}

	//MyPackage returns base::PackageCS:
	//	"package" name=UnrestrictedName (":" nsPrefix=UnrestrictedName)? ("=" nsURI=URI)? "{" ownedType+=MyClassCS* "}";
	public MyPackageElements getMyPackageAccess() {
		return (pMyPackage != null) ? pMyPackage : (pMyPackage = new MyPackageElements());
	}
	
	public ParserRule getMyPackageRule() {
		return getMyPackageAccess().getRule();
	}

	//MyClassCS returns base::ClassCS:
	//	"class" name=UnrestrictedName "{" ownedProperty+=MyProperty* ("constraint" ownedConstraint+=MyConstraintPrefix?
	//	ownedConstraint+=MyConstraint)* //(ownedConstraint += InvariantConstraintCS)*
	//	"}";
	public MyClassCSElements getMyClassCSAccess() {
		return (pMyClassCS != null) ? pMyClassCS : (pMyClassCS = new MyClassCSElements());
	}
	
	public ParserRule getMyClassCSRule() {
		return getMyClassCSAccess().getRule();
	}

	//MyProperty returns base::StructuralFeatureCS:
	//	MyAttributeCS | MyReference;
	public MyPropertyElements getMyPropertyAccess() {
		return (pMyProperty != null) ? pMyProperty : (pMyProperty = new MyPropertyElements());
	}
	
	public ParserRule getMyPropertyRule() {
		return getMyPropertyAccess().getRule();
	}

	//MyReference returns base::ReferenceCS:
	//	("ref" | qualifier+="contains") ownedType=TypedMultiplicityRefCS name=UnrestrictedName ("opposite"
	//	opposite=[pivot::Property|UnrestrictedName])? (ownedAnnotation+=MyPropertyDecoAnnotation | ":" "{"
	//	qualifier+="derived" ownedDefaultExpression+=SpecificationCS "}")?;
	public MyReferenceElements getMyReferenceAccess() {
		return (pMyReference != null) ? pMyReference : (pMyReference = new MyReferenceElements());
	}
	
	public ParserRule getMyReferenceRule() {
		return getMyReferenceAccess().getRule();
	}

	//MyAttributeCS returns base::AttributeCS:
	//	(ownedAnnotation+=MyConfig | qualifier+="id")? ownedType=TypedMultiplicityRefCS name=UnrestrictedName
	//	(ownedAnnotation+=MyPropertyDecoAnnotation | ":" "{" qualifier+="derived" ownedDefaultExpression+=SpecificationCS
	//	"}")?;
	public MyAttributeCSElements getMyAttributeCSAccess() {
		return (pMyAttributeCS != null) ? pMyAttributeCS : (pMyAttributeCS = new MyAttributeCSElements());
	}
	
	public ParserRule getMyAttributeCSRule() {
		return getMyAttributeCSAccess().getRule();
	}

	//MyPropertyDecoAnnotation returns base::AnnotationCS:
	//	":" "{" ownedDetail+=MyDomain? ownedDetail+=MyResistance? //(ownedDetail += MyDerivation)?
	//	"}";
	public MyPropertyDecoAnnotationElements getMyPropertyDecoAnnotationAccess() {
		return (pMyPropertyDecoAnnotation != null) ? pMyPropertyDecoAnnotation : (pMyPropertyDecoAnnotation = new MyPropertyDecoAnnotationElements());
	}
	
	public ParserRule getMyPropertyDecoAnnotationRule() {
		return getMyPropertyDecoAnnotationAccess().getRule();
	}

	//MyDerivation returns ext::ExpDetail:
	//	name="derivation" "=" expr+=SpecificationCS;
	public MyDerivationElements getMyDerivationAccess() {
		return (pMyDerivation != null) ? pMyDerivation : (pMyDerivation = new MyDerivationElements());
	}
	
	public ParserRule getMyDerivationRule() {
		return getMyDerivationAccess().getRule();
	}

	//MyResistance returns ext::ExpDetail:
	//	name="resistance" "=" expr+=SpecificationCS;
	public MyResistanceElements getMyResistanceAccess() {
		return (pMyResistance != null) ? pMyResistance : (pMyResistance = new MyResistanceElements());
	}
	
	public ParserRule getMyResistanceRule() {
		return getMyResistanceAccess().getRule();
	}

	//MyDomain returns ext::ExpDetail:
	//	name="domain" "=" expr+=SpecificationCS;
	public MyDomainElements getMyDomainAccess() {
		return (pMyDomain != null) ? pMyDomain : (pMyDomain = new MyDomainElements());
	}
	
	public ParserRule getMyDomainRule() {
		return getMyDomainAccess().getRule();
	}

	//MyConfig returns base::AnnotationCS:
	//	{base::AnnotationCS} name="config";
	public MyConfigElements getMyConfigAccess() {
		return (pMyConfig != null) ? pMyConfig : (pMyConfig = new MyConfigElements());
	}
	
	public ParserRule getMyConfigRule() {
		return getMyConfigAccess().getRule();
	}

	//MyConstraint returns base::ConstraintCS:
	//	name=UnrestrictedName ":" specification=SpecificationCS;
	public MyConstraintElements getMyConstraintAccess() {
		return (pMyConstraint != null) ? pMyConstraint : (pMyConstraint = new MyConstraintElements());
	}
	
	public ParserRule getMyConstraintRule() {
		return getMyConstraintAccess().getRule();
	}

	//MyConstraintPrefix returns base::ConstraintCS:
	//	MyConstraintHard | MyConstraintPriority;
	public MyConstraintPrefixElements getMyConstraintPrefixAccess() {
		return (pMyConstraintPrefix != null) ? pMyConstraintPrefix : (pMyConstraintPrefix = new MyConstraintPrefixElements());
	}
	
	public ParserRule getMyConstraintPrefixRule() {
		return getMyConstraintPrefixAccess().getRule();
	}

	//MyConstraintHard returns base::ConstraintCS:
	//	"(" name="hard" ")";
	public MyConstraintHardElements getMyConstraintHardAccess() {
		return (pMyConstraintHard != null) ? pMyConstraintHard : (pMyConstraintHard = new MyConstraintHardElements());
	}
	
	public ParserRule getMyConstraintHardRule() {
		return getMyConstraintHardAccess().getRule();
	}

	//MyConstraintPriority returns base::ConstraintCS:
	//	"(" name="priority" "=" specification=SpecificationCS ")";
	public MyConstraintPriorityElements getMyConstraintPriorityAccess() {
		return (pMyConstraintPriority != null) ? pMyConstraintPriority : (pMyConstraintPriority = new MyConstraintPriorityElements());
	}
	
	public ParserRule getMyConstraintPriorityRule() {
		return getMyConstraintPriorityAccess().getRule();
	}

	////generate oclinEcore2 "http://www.eclipse.org/ocl/examples/xtext/oclinecore/OCLinEcore"
	// RootPackageCS returns
	//base::RootPackageCS:
	//	{base::RootPackageCS} ("module" name=UnrestrictedName)? ownedLibrary+=LibraryCS* ownedImport+=ImportCS*
	//	ownedNestedPackage+=PackageCS*;
	public OCLinEcoreGrammarAccess.RootPackageCSElements getRootPackageCSAccess() {
		return gaOCLinEcore.getRootPackageCSAccess();
	}
	
	public ParserRule getRootPackageCSRule() {
		return getRootPackageCSAccess().getRule();
	}

	//// Never forward parsed; just provides a placeholder
	// terminal UNQUOTED_STRING:
	////  for reverse serialisation of embedded OCL 
	// "£$%^£$%^";
	public TerminalRule getUNQUOTED_STRINGRule() {
		return gaOCLinEcore.getUNQUOTED_STRINGRule();
	} 

	//INTEGER returns ecore::EInt:
	//	INT;
	public OCLinEcoreGrammarAccess.INTEGERElements getINTEGERAccess() {
		return gaOCLinEcore.getINTEGERAccess();
	}
	
	public ParserRule getINTEGERRule() {
		return getINTEGERAccess().getRule();
	}

	//EnumerationLiteralName returns ecore::EString:
	//	EssentialOCLUnrestrictedName | "abstract" | "attribute" | "body" | "callable" | "class" | "composes" | "datatype" |
	//	"definition" | "derivation" | "derived" | "enum" | "extends" | "id" | "import" | "initial" | "interface" | "key" |
	//	"library" | "module" | "operation" | "ordered" | "package" | "postcondition" | "precondition" | "property" |
	//	"readonly" | "reference" | "resolve" | "static" | "super" | "throws" | "transient" | "unique" | "unsettable" |
	//	"volatile";
	public OCLinEcoreGrammarAccess.EnumerationLiteralNameElements getEnumerationLiteralNameAccess() {
		return gaOCLinEcore.getEnumerationLiteralNameAccess();
	}
	
	public ParserRule getEnumerationLiteralNameRule() {
		return getEnumerationLiteralNameAccess().getRule();
	}

	//UnrestrictedName returns ecore::EString:
	//	EnumerationLiteralName | "annotation" | "documentation" | "invariant" | "literal" | "serializable" | "sysml";
	public OCLinEcoreGrammarAccess.UnrestrictedNameElements getUnrestrictedNameAccess() {
		return gaOCLinEcore.getUnrestrictedNameAccess();
	}
	
	public ParserRule getUnrestrictedNameRule() {
		return getUnrestrictedNameAccess().getRule();
	}

	//InvariantConstraintCS returns OCLinEcoreConstraintCS:
	//	callable?="callable"? stereotype="invariant" (name=UnrestrictedName ("(" messageSpecification=SpecificationCS ")")?)?
	//	(":" specification=SpecificationCS? ";" | ";");
	public OCLinEcoreGrammarAccess.InvariantConstraintCSElements getInvariantConstraintCSAccess() {
		return gaOCLinEcore.getInvariantConstraintCSAccess();
	}
	
	public ParserRule getInvariantConstraintCSRule() {
		return getInvariantConstraintCSAccess().getRule();
	}

	//PostconditionConstraintCS returns OCLinEcoreConstraintCS:
	//	stereotype="postcondition" name=UnrestrictedName? ":" specification=SpecificationCS? ";";
	public OCLinEcoreGrammarAccess.PostconditionConstraintCSElements getPostconditionConstraintCSAccess() {
		return gaOCLinEcore.getPostconditionConstraintCSAccess();
	}
	
	public ParserRule getPostconditionConstraintCSRule() {
		return getPostconditionConstraintCSAccess().getRule();
	}

	//PreconditionConstraintCS returns OCLinEcoreConstraintCS:
	//	stereotype="precondition" name=UnrestrictedName? ":" specification=SpecificationCS? ";";
	public OCLinEcoreGrammarAccess.PreconditionConstraintCSElements getPreconditionConstraintCSAccess() {
		return gaOCLinEcore.getPreconditionConstraintCSAccess();
	}
	
	public ParserRule getPreconditionConstraintCSRule() {
		return getPreconditionConstraintCSAccess().getRule();
	}

	//AnnotationCS returns base::AnnotationCS:
	//	{base::AnnotationCS} "annotation" name=(UnrestrictedName | SINGLE_QUOTED_STRING)? ("(" ownedDetail+=DetailCS (","
	//	ownedDetail+=DetailCS)* ")")? ("{" (ownedAnnotation+=AnnotationElementCS | ownedContent+=ModelElementCS |
	//	ownedReference+=ModelElementRefCS)+ "}" | ";");
	public OCLinEcoreGrammarAccess.AnnotationCSElements getAnnotationCSAccess() {
		return gaOCLinEcore.getAnnotationCSAccess();
	}
	
	public ParserRule getAnnotationCSRule() {
		return getAnnotationCSAccess().getRule();
	}

	//AnnotationElementCS returns base::AnnotationElementCS:
	//	AnnotationCS | DocumentationCS | SysMLCS;
	public OCLinEcoreGrammarAccess.AnnotationElementCSElements getAnnotationElementCSAccess() {
		return gaOCLinEcore.getAnnotationElementCSAccess();
	}
	
	public ParserRule getAnnotationElementCSRule() {
		return getAnnotationElementCSAccess().getRule();
	}

	//AttributeCS returns base::AttributeCS:
	//	(qualifier+="static" qualifier+="definition"? | qualifier+="definition" qualifier+="static"?)? "attribute"
	//	name=UnrestrictedName (":" ownedType=TypedMultiplicityRefCS)? ("=" default=SINGLE_QUOTED_STRING)? ("{"
	//	((qualifier+="derived" | qualifier+="!derived" | qualifier+="id" | qualifier+="!id" | qualifier+="ordered" |
	//	qualifier+="!ordered" | qualifier+="readonly" | qualifier+="!readonly" | qualifier+="transient" |
	//	qualifier+="!transient" | qualifier+="unique" | qualifier+="!unique" | qualifier+="unsettable" |
	//	qualifier+="!unsettable" | qualifier+="volatile" | qualifier+="!volatile") ","?)+ "}")? ("{"
	//	(ownedAnnotation+=AnnotationElementCS | "derivation" UnrestrictedName? ":" ownedDefaultExpression+=SpecificationCS?
	//	";" | "initial" UnrestrictedName? ":" ownedDefaultExpression+=SpecificationCS? ";")* "}" | ";");
	public OCLinEcoreGrammarAccess.AttributeCSElements getAttributeCSAccess() {
		return gaOCLinEcore.getAttributeCSAccess();
	}
	
	public ParserRule getAttributeCSRule() {
		return getAttributeCSAccess().getRule();
	}

	//ClassCS returns base::ClassCS:
	//	qualifier+="abstract"? "class" name=UnrestrictedName ownedTemplateSignature=TemplateSignatureCS? ("extends"
	//	ownedSuperType+=TypedRefCS ("," ownedSuperType+=TypedRefCS)*)? (":" instanceClassName=SINGLE_QUOTED_STRING)? ("{"
	//	qualifier+="interface" "}")? ("{" (ownedAnnotation+=AnnotationElementCS | ownedOperation+=OperationCS |
	//	ownedProperty+=StructuralFeatureCS | ownedConstraint+=InvariantConstraintCS)* "}" | ";");
	public OCLinEcoreGrammarAccess.ClassCSElements getClassCSAccess() {
		return gaOCLinEcore.getClassCSAccess();
	}
	
	public ParserRule getClassCSRule() {
		return getClassCSAccess().getRule();
	}

	//ClassifierCS returns base::ClassifierCS:
	//	ClassCS | DataTypeCS | EnumerationCS;
	public OCLinEcoreGrammarAccess.ClassifierCSElements getClassifierCSAccess() {
		return gaOCLinEcore.getClassifierCSAccess();
	}
	
	public ParserRule getClassifierCSRule() {
		return getClassifierCSAccess().getRule();
	}

	//CollectionTypeCS returns essentialocl::CollectionTypeCS:
	//	name=CollectionTypeIdentifier ("(" ownedType=TypeExpCS ")")?;
	public OCLinEcoreGrammarAccess.CollectionTypeCSElements getCollectionTypeCSAccess() {
		return gaOCLinEcore.getCollectionTypeCSAccess();
	}
	
	public ParserRule getCollectionTypeCSRule() {
		return getCollectionTypeCSAccess().getRule();
	}

	//DataTypeCS returns base::DataTypeCS:
	//	"datatype" name=UnrestrictedName ownedTemplateSignature=TemplateSignatureCS? (":"
	//	instanceClassName=SINGLE_QUOTED_STRING)? ("{" (qualifier+="serializable" | qualifier+="!serializable")? "}")? ("{"
	//	(ownedAnnotation+=AnnotationElementCS | ownedConstraint+=InvariantConstraintCS)* "}" | ";");
	public OCLinEcoreGrammarAccess.DataTypeCSElements getDataTypeCSAccess() {
		return gaOCLinEcore.getDataTypeCSAccess();
	}
	
	public ParserRule getDataTypeCSRule() {
		return getDataTypeCSAccess().getRule();
	}

	//DetailCS returns base::DetailCS:
	//	name=(UnrestrictedName | SINGLE_QUOTED_STRING) "=" value+=(SINGLE_QUOTED_STRING | ML_SINGLE_QUOTED_STRING)*;
	public OCLinEcoreGrammarAccess.DetailCSElements getDetailCSAccess() {
		return gaOCLinEcore.getDetailCSAccess();
	}
	
	public ParserRule getDetailCSRule() {
		return getDetailCSAccess().getRule();
	}

	//DocumentationCS returns base::DocumentationCS:
	//	{base::DocumentationCS} "documentation" value=SINGLE_QUOTED_STRING? ("(" ownedDetail+=DetailCS (","
	//	ownedDetail+=DetailCS)* ")")? ";";
	public OCLinEcoreGrammarAccess.DocumentationCSElements getDocumentationCSAccess() {
		return gaOCLinEcore.getDocumentationCSAccess();
	}
	
	public ParserRule getDocumentationCSRule() {
		return getDocumentationCSAccess().getRule();
	}

	//EnumerationCS returns base::EnumerationCS:
	//	"enum" name=UnrestrictedName ownedTemplateSignature=TemplateSignatureCS? (":"
	//	instanceClassName=SINGLE_QUOTED_STRING)? ("{" (qualifier+="serializable" | qualifier+="!serializable")? "}")? ("{"
	//	(ownedAnnotation+=AnnotationElementCS | ownedLiterals+=EnumerationLiteralCS |
	//	ownedConstraint+=InvariantConstraintCS)* "}" | ";");
	public OCLinEcoreGrammarAccess.EnumerationCSElements getEnumerationCSAccess() {
		return gaOCLinEcore.getEnumerationCSAccess();
	}
	
	public ParserRule getEnumerationCSRule() {
		return getEnumerationCSAccess().getRule();
	}

	//EnumerationLiteralCS returns base::EnumerationLiteralCS:
	//	("literal" name=UnrestrictedName | name=EnumerationLiteralName) ("=" value=INTEGER)? ("{"
	//	ownedAnnotation+=AnnotationElementCS* "}" | ";");
	public OCLinEcoreGrammarAccess.EnumerationLiteralCSElements getEnumerationLiteralCSAccess() {
		return gaOCLinEcore.getEnumerationLiteralCSAccess();
	}
	
	public ParserRule getEnumerationLiteralCSRule() {
		return getEnumerationLiteralCSAccess().getRule();
	}

	//ImportCS returns base::ImportCS:
	//	"import" (name=UnrestrictedName ":")? pathName=URIPathNameCS (all?="::" "*")? ";";
	public OCLinEcoreGrammarAccess.ImportCSElements getImportCSAccess() {
		return gaOCLinEcore.getImportCSAccess();
	}
	
	public ParserRule getImportCSRule() {
		return getImportCSAccess().getRule();
	}

	//LibraryCS returns base::LibraryCS:
	//	"library" (name=UnrestrictedName ":")? package=[pivot::Package|URI] ";";
	public OCLinEcoreGrammarAccess.LibraryCSElements getLibraryCSAccess() {
		return gaOCLinEcore.getLibraryCSAccess();
	}
	
	public ParserRule getLibraryCSRule() {
		return getLibraryCSAccess().getRule();
	}

	//ModelElementCS returns base::ModelElementCS:
	//	ClassifierCS | EnumerationLiteralCS | OperationCS | PackageCS | StructuralFeatureCS;
	public OCLinEcoreGrammarAccess.ModelElementCSElements getModelElementCSAccess() {
		return gaOCLinEcore.getModelElementCSAccess();
	}
	
	public ParserRule getModelElementCSRule() {
		return getModelElementCSAccess().getRule();
	}

	//ModelElementRefCS returns base::ModelElementRefCS:
	//	"reference" pathName=PathNameCS ";";
	public OCLinEcoreGrammarAccess.ModelElementRefCSElements getModelElementRefCSAccess() {
		return gaOCLinEcore.getModelElementRefCSAccess();
	}
	
	public ParserRule getModelElementRefCSRule() {
		return getModelElementRefCSAccess().getRule();
	}

	//OperationCS returns base::OperationCS:
	//	(qualifier+="static" qualifier+="definition"? | qualifier+="definition" qualifier+="static"?)? "operation"
	//	ownedTemplateSignature=TemplateSignatureCS? name=UnrestrictedName "(" (ownedParameter+=ParameterCS (","
	//	ownedParameter+=ParameterCS)*)? ")" (":" ownedType=TypedMultiplicityRefCS)? ("throws" ownedException+=TypedRefCS (","
	//	ownedException+=TypedRefCS)*)? ("{" ((qualifier+="derived" | qualifier+="!derived" | qualifier+="ordered" |
	//	qualifier+="!ordered" | qualifier+="unique" | qualifier+="!unique") ","?)+ "}")? ("{"
	//	(ownedAnnotation+=AnnotationElementCS | ownedPrecondition+=PreconditionConstraintCS | "body" UnrestrictedName? ":"
	//	ownedBodyExpression+=SpecificationCS? ";" | ownedPostcondition+=PostconditionConstraintCS)* "}" | ";");
	public OCLinEcoreGrammarAccess.OperationCSElements getOperationCSAccess() {
		return gaOCLinEcore.getOperationCSAccess();
	}
	
	public ParserRule getOperationCSRule() {
		return getOperationCSAccess().getRule();
	}

	//PackageCS returns base::PackageCS:
	//	"package" name=UnrestrictedName (":" nsPrefix=UnrestrictedName)? ("=" nsURI=URI)? ("{"
	//	(ownedAnnotation+=AnnotationElementCS | ownedNestedPackage+=PackageCS | ownedType+=ClassifierCS)* "}" | ";");
	public OCLinEcoreGrammarAccess.PackageCSElements getPackageCSAccess() {
		return gaOCLinEcore.getPackageCSAccess();
	}
	
	public ParserRule getPackageCSRule() {
		return getPackageCSAccess().getRule();
	}

	//ParameterCS returns base::ParameterCS:
	//	name=UnrestrictedName (":" ownedType=TypedMultiplicityRefCS)? ("{" ((qualifier+="ordered" | qualifier+="!ordered" |
	//	qualifier+="unique" | qualifier+="!unique") ","?)+ "}")? ("{" ownedAnnotation+=AnnotationElementCS* "}")?;
	public OCLinEcoreGrammarAccess.ParameterCSElements getParameterCSAccess() {
		return gaOCLinEcore.getParameterCSAccess();
	}
	
	public ParserRule getParameterCSRule() {
		return getParameterCSAccess().getRule();
	}

	//ReferenceCS returns base::ReferenceCS:
	//	(qualifier+="static" qualifier+="definition"? | qualifier+="definition" qualifier+="static"?)? "property"
	//	name=UnrestrictedName ("#" opposite=[pivot::Property|UnrestrictedName])? (":" ownedType=TypedMultiplicityRefCS)? ("="
	//	default=SINGLE_QUOTED_STRING)? ("{" ((qualifier+="composes" | qualifier+="!composes" | qualifier+="derived" |
	//	qualifier+="!derived" | qualifier+="ordered" | qualifier+="!ordered" | qualifier+="readonly" | qualifier+="!readonly"
	//	| qualifier+="resolve" | qualifier+="!resolve" | qualifier+="transient" | qualifier+="!transient" |
	//	qualifier+="unique" | qualifier+="!unique" | qualifier+="unsettable" | qualifier+="!unsettable" |
	//	qualifier+="volatile" | qualifier+="!volatile") ","?)+ "}")? ("{" (ownedAnnotation+=AnnotationElementCS | "key"
	//	keys+=[pivot::Property|UnrestrictedName] ("," keys+=[pivot::Property|UnrestrictedName])* ";" | "derivation"
	//	UnrestrictedName? ":" ownedDefaultExpression+=SpecificationCS? ";" | "initial" UnrestrictedName? ":"
	//	ownedDefaultExpression+=SpecificationCS? ";")* "}" | ";");
	public OCLinEcoreGrammarAccess.ReferenceCSElements getReferenceCSAccess() {
		return gaOCLinEcore.getReferenceCSAccess();
	}
	
	public ParserRule getReferenceCSRule() {
		return getReferenceCSAccess().getRule();
	}

	//SpecificationCS returns essentialocl::ExpSpecificationCS:
	//	ownedExpression=ExpCS | exprString=UNQUOTED_STRING;
	public OCLinEcoreGrammarAccess.SpecificationCSElements getSpecificationCSAccess() {
		return gaOCLinEcore.getSpecificationCSAccess();
	}
	
	public ParserRule getSpecificationCSRule() {
		return getSpecificationCSAccess().getRule();
	}

	//StructuralFeatureCS returns base::StructuralFeatureCS:
	//	AttributeCS | ReferenceCS;
	public OCLinEcoreGrammarAccess.StructuralFeatureCSElements getStructuralFeatureCSAccess() {
		return gaOCLinEcore.getStructuralFeatureCSAccess();
	}
	
	public ParserRule getStructuralFeatureCSRule() {
		return getStructuralFeatureCSAccess().getRule();
	}

	//SysMLCS:
	//	{SysMLCS} "sysml" (ownedDetail+=DetailCS ";" | "{" (ownedDetail+=DetailCS ";")* "}");
	public OCLinEcoreGrammarAccess.SysMLCSElements getSysMLCSAccess() {
		return gaOCLinEcore.getSysMLCSAccess();
	}
	
	public ParserRule getSysMLCSRule() {
		return getSysMLCSAccess().getRule();
	}

	//TemplateBindingCS returns base::TemplateBindingCS:
	//	"(" ownedParameterSubstitution+=TemplateParameterSubstitutionCS (","
	//	ownedParameterSubstitution+=TemplateParameterSubstitutionCS)* ")" | "<"
	//	ownedParameterSubstitution+=TemplateParameterSubstitutionCS (","
	//	ownedParameterSubstitution+=TemplateParameterSubstitutionCS)* ">";
	public OCLinEcoreGrammarAccess.TemplateBindingCSElements getTemplateBindingCSAccess() {
		return gaOCLinEcore.getTemplateBindingCSAccess();
	}
	
	public ParserRule getTemplateBindingCSRule() {
		return getTemplateBindingCSAccess().getRule();
	}

	//TemplateParameterSubstitutionCS returns base::TemplateParameterSubstitutionCS:
	//	ownedActualParameter=TypeRefCS;
	public OCLinEcoreGrammarAccess.TemplateParameterSubstitutionCSElements getTemplateParameterSubstitutionCSAccess() {
		return gaOCLinEcore.getTemplateParameterSubstitutionCSAccess();
	}
	
	public ParserRule getTemplateParameterSubstitutionCSRule() {
		return getTemplateParameterSubstitutionCSAccess().getRule();
	}

	//TemplateSignatureCS returns base::TemplateSignatureCS:
	//	"(" ownedTemplateParameter+=TypeParameterCS ("," ownedTemplateParameter+=TypeParameterCS)* ")" | "<"
	//	ownedTemplateParameter+=TypeParameterCS ("," ownedTemplateParameter+=TypeParameterCS)* ">";
	public OCLinEcoreGrammarAccess.TemplateSignatureCSElements getTemplateSignatureCSAccess() {
		return gaOCLinEcore.getTemplateSignatureCSAccess();
	}
	
	public ParserRule getTemplateSignatureCSRule() {
		return getTemplateSignatureCSAccess().getRule();
	}

	//TypeIdentifier:
	//	UnrestrictedName | PrimitiveTypeIdentifier;
	public OCLinEcoreGrammarAccess.TypeIdentifierElements getTypeIdentifierAccess() {
		return gaOCLinEcore.getTypeIdentifierAccess();
	}
	
	public ParserRule getTypeIdentifierRule() {
		return getTypeIdentifierAccess().getRule();
	}

	//TypeParameterCS returns base::TypeParameterCS:
	//	name=UnrestrictedName ("extends" ownedExtends+=TypedRefCS ("&&" ownedExtends+=TypedRefCS)* | "super"
	//	ownedSuper=TypedRefCS)?;
	public OCLinEcoreGrammarAccess.TypeParameterCSElements getTypeParameterCSAccess() {
		return gaOCLinEcore.getTypeParameterCSAccess();
	}
	
	public ParserRule getTypeParameterCSRule() {
		return getTypeParameterCSAccess().getRule();
	}

	//TypeRefCS returns base::TypeRefCS:
	//	TypedRefCS | WildcardTypeRefCS;
	public OCLinEcoreGrammarAccess.TypeRefCSElements getTypeRefCSAccess() {
		return gaOCLinEcore.getTypeRefCSAccess();
	}
	
	public ParserRule getTypeRefCSRule() {
		return getTypeRefCSAccess().getRule();
	}

	//TypedRefCS returns base::TypedRefCS:
	//	TypeLiteralCS | TypedTypeRefCS;
	public OCLinEcoreGrammarAccess.TypedRefCSElements getTypedRefCSAccess() {
		return gaOCLinEcore.getTypedRefCSAccess();
	}
	
	public ParserRule getTypedRefCSRule() {
		return getTypedRefCSAccess().getRule();
	}

	//TypedMultiplicityRefCS returns base::TypedRefCS:
	//	TypedRefCS multiplicity=MultiplicityCS?;
	public OCLinEcoreGrammarAccess.TypedMultiplicityRefCSElements getTypedMultiplicityRefCSAccess() {
		return gaOCLinEcore.getTypedMultiplicityRefCSAccess();
	}
	
	public ParserRule getTypedMultiplicityRefCSRule() {
		return getTypedMultiplicityRefCSAccess().getRule();
	}

	//TypedTypeRefCS returns base::TypedTypeRefCS:
	//	pathName=PathNameCS ownedTemplateBinding=TemplateBindingCS?;
	public OCLinEcoreGrammarAccess.TypedTypeRefCSElements getTypedTypeRefCSAccess() {
		return gaOCLinEcore.getTypedTypeRefCSAccess();
	}
	
	public ParserRule getTypedTypeRefCSRule() {
		return getTypedTypeRefCSAccess().getRule();
	}

	//WildcardTypeRefCS returns base::WildcardTypeRefCS:
	//	{base::WildcardTypeRefCS} "?" ("extends" extends=TypedRefCS | "super" super=TypedRefCS)?;
	public OCLinEcoreGrammarAccess.WildcardTypeRefCSElements getWildcardTypeRefCSAccess() {
		return gaOCLinEcore.getWildcardTypeRefCSAccess();
	}
	
	public ParserRule getWildcardTypeRefCSRule() {
		return getWildcardTypeRefCSAccess().getRule();
	}

	////generate essentialOCLCST "http://www.eclipse.org/ocl/3.0.0/EssentialOCLCST"
	// Model returns ContextCS:
	//	ownedExpression=ExpCS;
	public EssentialOCLGrammarAccess.ModelElements getModelAccess() {
		return gaOCLinEcore.getModelAccess();
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//terminal fragment ESCAPED_CHARACTER:
	//	"\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\");
	public TerminalRule getESCAPED_CHARACTERRule() {
		return gaOCLinEcore.getESCAPED_CHARACTERRule();
	} 

	//terminal fragment LETTER_CHARACTER:
	//	"a".."z" | "A".."Z" | "_";
	public TerminalRule getLETTER_CHARACTERRule() {
		return gaOCLinEcore.getLETTER_CHARACTERRule();
	} 

	//terminal DOUBLE_QUOTED_STRING:
	//	"\"" (ESCAPED_CHARACTER | !("\\" | "\""))* "\"";
	public TerminalRule getDOUBLE_QUOTED_STRINGRule() {
		return gaOCLinEcore.getDOUBLE_QUOTED_STRINGRule();
	} 

	//terminal SINGLE_QUOTED_STRING:
	//	"\'" (ESCAPED_CHARACTER | !("\\" | "\'"))* "\'";
	public TerminalRule getSINGLE_QUOTED_STRINGRule() {
		return gaOCLinEcore.getSINGLE_QUOTED_STRINGRule();
	} 

	//terminal ML_SINGLE_QUOTED_STRING:
	//	"/\'"->"\'/";
	public TerminalRule getML_SINGLE_QUOTED_STRINGRule() {
		return gaOCLinEcore.getML_SINGLE_QUOTED_STRINGRule();
	} 

	//terminal SIMPLE_ID:
	//	LETTER_CHARACTER (LETTER_CHARACTER | "0".."9")*;
	public TerminalRule getSIMPLE_IDRule() {
		return gaOCLinEcore.getSIMPLE_IDRule();
	} 

	//terminal ESCAPED_ID:
	//	"_" SINGLE_QUOTED_STRING;
	public TerminalRule getESCAPED_IDRule() {
		return gaOCLinEcore.getESCAPED_IDRule();
	} 

	//ID:
	//	SIMPLE_ID | ESCAPED_ID;
	public EssentialOCLGrammarAccess.IDElements getIDAccess() {
		return gaOCLinEcore.getIDAccess();
	}
	
	public ParserRule getIDRule() {
		return getIDAccess().getRule();
	}

	//// String to allow diverse re-use
	// // multiple leading zeroes occur as floating point fractional part
	// terminal INT:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaOCLinEcore.getINTRule();
	} 

	//LOWER returns ecore::EInt:
	//	INT;
	public EssentialOCLGrammarAccess.LOWERElements getLOWERAccess() {
		return gaOCLinEcore.getLOWERAccess();
	}
	
	public ParserRule getLOWERRule() {
		return getLOWERAccess().getRule();
	}

	//UPPER returns ecore::EInt:
	//	INT | "*";
	public EssentialOCLGrammarAccess.UPPERElements getUPPERAccess() {
		return gaOCLinEcore.getUPPERAccess();
	}
	
	public ParserRule getUPPERRule() {
		return getUPPERAccess().getRule();
	}

	//// Not terminal to allow parser backtracking to sort out "5..7"
	//
	//// EssentialOCLTokenSource pieces this together ('.' INT)? (('e' | 'E') ('+' | '-')? INT)?;
	// NUMBER_LITERAL returns
	//BigNumber:
	//	INT;
	public EssentialOCLGrammarAccess.NUMBER_LITERALElements getNUMBER_LITERALAccess() {
		return gaOCLinEcore.getNUMBER_LITERALAccess();
	}
	
	public ParserRule getNUMBER_LITERALRule() {
		return getNUMBER_LITERALAccess().getRule();
	}

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaOCLinEcore.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"--" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaOCLinEcore.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaOCLinEcore.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaOCLinEcore.getANY_OTHERRule();
	} 

	//URI:
	//	SINGLE_QUOTED_STRING;
	public EssentialOCLGrammarAccess.URIElements getURIAccess() {
		return gaOCLinEcore.getURIAccess();
	}
	
	public ParserRule getURIRule() {
		return getURIAccess().getRule();
	}

	//EssentialOCLReservedKeyword:
	//	"and" | "else" | "endif" | "if" | "implies" | "in" | "let" | "not" | "or" | "then" | "xor";
	public EssentialOCLGrammarAccess.EssentialOCLReservedKeywordElements getEssentialOCLReservedKeywordAccess() {
		return gaOCLinEcore.getEssentialOCLReservedKeywordAccess();
	}
	
	public ParserRule getEssentialOCLReservedKeywordRule() {
		return getEssentialOCLReservedKeywordAccess().getRule();
	}

	//EssentialOCLUnaryOperatorCS returns UnaryOperatorCS:
	//	name=("-" | "not");
	public EssentialOCLGrammarAccess.EssentialOCLUnaryOperatorCSElements getEssentialOCLUnaryOperatorCSAccess() {
		return gaOCLinEcore.getEssentialOCLUnaryOperatorCSAccess();
	}
	
	public ParserRule getEssentialOCLUnaryOperatorCSRule() {
		return getEssentialOCLUnaryOperatorCSAccess().getRule();
	}

	//EssentialOCLInfixOperatorCS returns BinaryOperatorCS:
	//	name=("*" | "/" | "+" | "-" | ">" | "<" | ">=" | "<=" | "=" | "<>" | "and" | "or" | "xor" | "implies");
	public EssentialOCLGrammarAccess.EssentialOCLInfixOperatorCSElements getEssentialOCLInfixOperatorCSAccess() {
		return gaOCLinEcore.getEssentialOCLInfixOperatorCSAccess();
	}
	
	public ParserRule getEssentialOCLInfixOperatorCSRule() {
		return getEssentialOCLInfixOperatorCSAccess().getRule();
	}

	//EssentialOCLNavigationOperatorCS returns NavigationOperatorCS:
	//	name=("." | "->");
	public EssentialOCLGrammarAccess.EssentialOCLNavigationOperatorCSElements getEssentialOCLNavigationOperatorCSAccess() {
		return gaOCLinEcore.getEssentialOCLNavigationOperatorCSAccess();
	}
	
	public ParserRule getEssentialOCLNavigationOperatorCSRule() {
		return getEssentialOCLNavigationOperatorCSAccess().getRule();
	}

	//Identifier:
	//	ID;
	public EssentialOCLGrammarAccess.IdentifierElements getIdentifierAccess() {
		return gaOCLinEcore.getIdentifierAccess();
	}
	
	public ParserRule getIdentifierRule() {
		return getIdentifierAccess().getRule();
	}

	//StringLiteral:
	//	SINGLE_QUOTED_STRING;
	public EssentialOCLGrammarAccess.StringLiteralElements getStringLiteralAccess() {
		return gaOCLinEcore.getStringLiteralAccess();
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}

	//BinaryOperatorCS:
	//	InfixOperatorCS | NavigationOperatorCS;
	public EssentialOCLGrammarAccess.BinaryOperatorCSElements getBinaryOperatorCSAccess() {
		return gaOCLinEcore.getBinaryOperatorCSAccess();
	}
	
	public ParserRule getBinaryOperatorCSRule() {
		return getBinaryOperatorCSAccess().getRule();
	}

	//// Intended to be overrideable
	// InfixOperatorCS returns BinaryOperatorCS:
	//	EssentialOCLInfixOperatorCS;
	public EssentialOCLGrammarAccess.InfixOperatorCSElements getInfixOperatorCSAccess() {
		return gaOCLinEcore.getInfixOperatorCSAccess();
	}
	
	public ParserRule getInfixOperatorCSRule() {
		return getInfixOperatorCSAccess().getRule();
	}

	//// Intended to be overrideable
	// NavigationOperatorCS:
	//	EssentialOCLNavigationOperatorCS;
	public EssentialOCLGrammarAccess.NavigationOperatorCSElements getNavigationOperatorCSAccess() {
		return gaOCLinEcore.getNavigationOperatorCSAccess();
	}
	
	public ParserRule getNavigationOperatorCSRule() {
		return getNavigationOperatorCSAccess().getRule();
	}

	//// Intended to be overrideable
	// UnaryOperatorCS:
	//	EssentialOCLUnaryOperatorCS;
	public EssentialOCLGrammarAccess.UnaryOperatorCSElements getUnaryOperatorCSAccess() {
		return gaOCLinEcore.getUnaryOperatorCSAccess();
	}
	
	public ParserRule getUnaryOperatorCSRule() {
		return getUnaryOperatorCSAccess().getRule();
	}

	////---------------------------------------------------------------------
	// //  Names
	//
	////---------------------------------------------------------------------
	// EssentialOCLUnrestrictedName returns
	//ecore::EString:
	//	Identifier;
	public EssentialOCLGrammarAccess.EssentialOCLUnrestrictedNameElements getEssentialOCLUnrestrictedNameAccess() {
		return gaOCLinEcore.getEssentialOCLUnrestrictedNameAccess();
	}
	
	public ParserRule getEssentialOCLUnrestrictedNameRule() {
		return getEssentialOCLUnrestrictedNameAccess().getRule();
	}

	//EssentialOCLUnreservedName returns ecore::EString:
	//	UnrestrictedName | CollectionTypeIdentifier | PrimitiveTypeIdentifier | "Tuple";
	public EssentialOCLGrammarAccess.EssentialOCLUnreservedNameElements getEssentialOCLUnreservedNameAccess() {
		return gaOCLinEcore.getEssentialOCLUnreservedNameAccess();
	}
	
	public ParserRule getEssentialOCLUnreservedNameRule() {
		return getEssentialOCLUnreservedNameAccess().getRule();
	}

	//// Intended to be overridden
	// UnreservedName returns ecore::EString:
	//	EssentialOCLUnreservedName;
	public EssentialOCLGrammarAccess.UnreservedNameElements getUnreservedNameAccess() {
		return gaOCLinEcore.getUnreservedNameAccess();
	}
	
	public ParserRule getUnreservedNameRule() {
		return getUnreservedNameAccess().getRule();
	}

	//PathNameCS returns base::PathNameCS:
	//	path+=FirstPathElementCS ("::" path+=NextPathElementCS)*;
	public EssentialOCLGrammarAccess.PathNameCSElements getPathNameCSAccess() {
		return gaOCLinEcore.getPathNameCSAccess();
	}
	
	public ParserRule getPathNameCSRule() {
		return getPathNameCSAccess().getRule();
	}

	//FirstPathElementCS returns base::PathElementCS:
	//	element=[pivot::NamedElement|UnrestrictedName];
	public EssentialOCLGrammarAccess.FirstPathElementCSElements getFirstPathElementCSAccess() {
		return gaOCLinEcore.getFirstPathElementCSAccess();
	}
	
	public ParserRule getFirstPathElementCSRule() {
		return getFirstPathElementCSAccess().getRule();
	}

	//NextPathElementCS returns base::PathElementCS:
	//	element=[pivot::NamedElement|UnreservedName];
	public EssentialOCLGrammarAccess.NextPathElementCSElements getNextPathElementCSAccess() {
		return gaOCLinEcore.getNextPathElementCSAccess();
	}
	
	public ParserRule getNextPathElementCSRule() {
		return getNextPathElementCSAccess().getRule();
	}

	//URIPathNameCS returns base::PathNameCS:
	//	path+=URIFirstPathElementCS ("::" path+=NextPathElementCS)*;
	public EssentialOCLGrammarAccess.URIPathNameCSElements getURIPathNameCSAccess() {
		return gaOCLinEcore.getURIPathNameCSAccess();
	}
	
	public ParserRule getURIPathNameCSRule() {
		return getURIPathNameCSAccess().getRule();
	}

	//URIFirstPathElementCS returns base::PathElementCS:
	//	element=[pivot::NamedElement|UnrestrictedName] | {base::PathElementWithURICS} element=[pivot::Namespace|URI];
	public EssentialOCLGrammarAccess.URIFirstPathElementCSElements getURIFirstPathElementCSAccess() {
		return gaOCLinEcore.getURIFirstPathElementCSAccess();
	}
	
	public ParserRule getURIFirstPathElementCSRule() {
		return getURIFirstPathElementCSAccess().getRule();
	}

	////---------------------------------------------------------------------
	// //  Types
	//
	////---------------------------------------------------------------------
	// PrimitiveTypeIdentifier:
	//	"Boolean" | "Integer" | "Real" | "String" | "UnlimitedNatural" | "OclAny" | "OclInvalid" | "OclVoid";
	public EssentialOCLGrammarAccess.PrimitiveTypeIdentifierElements getPrimitiveTypeIdentifierAccess() {
		return gaOCLinEcore.getPrimitiveTypeIdentifierAccess();
	}
	
	public ParserRule getPrimitiveTypeIdentifierRule() {
		return getPrimitiveTypeIdentifierAccess().getRule();
	}

	//PrimitiveTypeCS returns base::PrimitiveTypeRefCS:
	//	name=PrimitiveTypeIdentifier;
	public EssentialOCLGrammarAccess.PrimitiveTypeCSElements getPrimitiveTypeCSAccess() {
		return gaOCLinEcore.getPrimitiveTypeCSAccess();
	}
	
	public ParserRule getPrimitiveTypeCSRule() {
		return getPrimitiveTypeCSAccess().getRule();
	}

	//CollectionTypeIdentifier returns ecore::EString:
	//	"Set" | "Bag" | "Sequence" | "Collection" | "OrderedSet";
	public EssentialOCLGrammarAccess.CollectionTypeIdentifierElements getCollectionTypeIdentifierAccess() {
		return gaOCLinEcore.getCollectionTypeIdentifierAccess();
	}
	
	public ParserRule getCollectionTypeIdentifierRule() {
		return getCollectionTypeIdentifierAccess().getRule();
	}

	//MultiplicityBoundsCS returns base::MultiplicityBoundsCS:
	//	lowerBound=LOWER (".." upperBound=UPPER)?;
	public EssentialOCLGrammarAccess.MultiplicityBoundsCSElements getMultiplicityBoundsCSAccess() {
		return gaOCLinEcore.getMultiplicityBoundsCSAccess();
	}
	
	public ParserRule getMultiplicityBoundsCSRule() {
		return getMultiplicityBoundsCSAccess().getRule();
	}

	//MultiplicityCS returns base::MultiplicityCS:
	//	"[" (MultiplicityBoundsCS | MultiplicityStringCS) "]";
	public EssentialOCLGrammarAccess.MultiplicityCSElements getMultiplicityCSAccess() {
		return gaOCLinEcore.getMultiplicityCSAccess();
	}
	
	public ParserRule getMultiplicityCSRule() {
		return getMultiplicityCSAccess().getRule();
	}

	//MultiplicityStringCS returns base::MultiplicityStringCS:
	//	stringBounds=("*" | "+" | "?");
	public EssentialOCLGrammarAccess.MultiplicityStringCSElements getMultiplicityStringCSAccess() {
		return gaOCLinEcore.getMultiplicityStringCSAccess();
	}
	
	public ParserRule getMultiplicityStringCSRule() {
		return getMultiplicityStringCSAccess().getRule();
	}

	//TupleTypeCS returns base::TupleTypeCS:
	//	name="Tuple" ("(" (ownedParts+=TuplePartCS ("," ownedParts+=TuplePartCS)*)? ")")?;
	public EssentialOCLGrammarAccess.TupleTypeCSElements getTupleTypeCSAccess() {
		return gaOCLinEcore.getTupleTypeCSAccess();
	}
	
	public ParserRule getTupleTypeCSRule() {
		return getTupleTypeCSAccess().getRule();
	}

	//TuplePartCS returns base::TuplePartCS:
	//	name=UnrestrictedName ":" ownedType=TypeExpCS;
	public EssentialOCLGrammarAccess.TuplePartCSElements getTuplePartCSAccess() {
		return gaOCLinEcore.getTuplePartCSAccess();
	}
	
	public ParserRule getTuplePartCSRule() {
		return getTuplePartCSAccess().getRule();
	}

	////---------------------------------------------------------------------
	// //  Literals
	//
	////---------------------------------------------------------------------
	// CollectionLiteralExpCS:
	//	ownedType=CollectionTypeCS "{" (ownedParts+=CollectionLiteralPartCS ("," ownedParts+=CollectionLiteralPartCS)*)? "}";
	public EssentialOCLGrammarAccess.CollectionLiteralExpCSElements getCollectionLiteralExpCSAccess() {
		return gaOCLinEcore.getCollectionLiteralExpCSAccess();
	}
	
	public ParserRule getCollectionLiteralExpCSRule() {
		return getCollectionLiteralExpCSAccess().getRule();
	}

	//CollectionLiteralPartCS:
	//	expressionCS=ExpCS (".." lastExpressionCS=ExpCS)?;
	public EssentialOCLGrammarAccess.CollectionLiteralPartCSElements getCollectionLiteralPartCSAccess() {
		return gaOCLinEcore.getCollectionLiteralPartCSAccess();
	}
	
	public ParserRule getCollectionLiteralPartCSRule() {
		return getCollectionLiteralPartCSAccess().getRule();
	}

	//ConstructorPartCS:
	//	property=[pivot::Property|UnrestrictedName] "=" initExpression=ExpCS;
	public EssentialOCLGrammarAccess.ConstructorPartCSElements getConstructorPartCSAccess() {
		return gaOCLinEcore.getConstructorPartCSAccess();
	}
	
	public ParserRule getConstructorPartCSRule() {
		return getConstructorPartCSAccess().getRule();
	}

	//PrimitiveLiteralExpCS:
	//	NumberLiteralExpCS | StringLiteralExpCS | BooleanLiteralExpCS | UnlimitedNaturalLiteralExpCS | InvalidLiteralExpCS |
	//	NullLiteralExpCS;
	public EssentialOCLGrammarAccess.PrimitiveLiteralExpCSElements getPrimitiveLiteralExpCSAccess() {
		return gaOCLinEcore.getPrimitiveLiteralExpCSAccess();
	}
	
	public ParserRule getPrimitiveLiteralExpCSRule() {
		return getPrimitiveLiteralExpCSAccess().getRule();
	}

	//TupleLiteralExpCS:
	//	"Tuple" "{" ownedParts+=TupleLiteralPartCS ("," ownedParts+=TupleLiteralPartCS)* "}";
	public EssentialOCLGrammarAccess.TupleLiteralExpCSElements getTupleLiteralExpCSAccess() {
		return gaOCLinEcore.getTupleLiteralExpCSAccess();
	}
	
	public ParserRule getTupleLiteralExpCSRule() {
		return getTupleLiteralExpCSAccess().getRule();
	}

	//TupleLiteralPartCS:
	//	name=UnrestrictedName (":" ownedType=TypeExpCS)? "=" initExpression=ExpCS;
	public EssentialOCLGrammarAccess.TupleLiteralPartCSElements getTupleLiteralPartCSAccess() {
		return gaOCLinEcore.getTupleLiteralPartCSAccess();
	}
	
	public ParserRule getTupleLiteralPartCSRule() {
		return getTupleLiteralPartCSAccess().getRule();
	}

	//NumberLiteralExpCS:
	//	name=NUMBER_LITERAL;
	public EssentialOCLGrammarAccess.NumberLiteralExpCSElements getNumberLiteralExpCSAccess() {
		return gaOCLinEcore.getNumberLiteralExpCSAccess();
	}
	
	public ParserRule getNumberLiteralExpCSRule() {
		return getNumberLiteralExpCSAccess().getRule();
	}

	//StringLiteralExpCS:
	//	name+=StringLiteral+;
	public EssentialOCLGrammarAccess.StringLiteralExpCSElements getStringLiteralExpCSAccess() {
		return gaOCLinEcore.getStringLiteralExpCSAccess();
	}
	
	public ParserRule getStringLiteralExpCSRule() {
		return getStringLiteralExpCSAccess().getRule();
	}

	//BooleanLiteralExpCS:
	//	name="true" | name="false";
	public EssentialOCLGrammarAccess.BooleanLiteralExpCSElements getBooleanLiteralExpCSAccess() {
		return gaOCLinEcore.getBooleanLiteralExpCSAccess();
	}
	
	public ParserRule getBooleanLiteralExpCSRule() {
		return getBooleanLiteralExpCSAccess().getRule();
	}

	//UnlimitedNaturalLiteralExpCS:
	//	{UnlimitedNaturalLiteralExpCS} "*";
	public EssentialOCLGrammarAccess.UnlimitedNaturalLiteralExpCSElements getUnlimitedNaturalLiteralExpCSAccess() {
		return gaOCLinEcore.getUnlimitedNaturalLiteralExpCSAccess();
	}
	
	public ParserRule getUnlimitedNaturalLiteralExpCSRule() {
		return getUnlimitedNaturalLiteralExpCSAccess().getRule();
	}

	//InvalidLiteralExpCS:
	//	{InvalidLiteralExpCS} "invalid";
	public EssentialOCLGrammarAccess.InvalidLiteralExpCSElements getInvalidLiteralExpCSAccess() {
		return gaOCLinEcore.getInvalidLiteralExpCSAccess();
	}
	
	public ParserRule getInvalidLiteralExpCSRule() {
		return getInvalidLiteralExpCSAccess().getRule();
	}

	//NullLiteralExpCS:
	//	{NullLiteralExpCS} "null";
	public EssentialOCLGrammarAccess.NullLiteralExpCSElements getNullLiteralExpCSAccess() {
		return gaOCLinEcore.getNullLiteralExpCSAccess();
	}
	
	public ParserRule getNullLiteralExpCSRule() {
		return getNullLiteralExpCSAccess().getRule();
	}

	//TypeLiteralCS returns base::TypedRefCS:
	//	PrimitiveTypeCS | CollectionTypeCS | TupleTypeCS;
	public EssentialOCLGrammarAccess.TypeLiteralCSElements getTypeLiteralCSAccess() {
		return gaOCLinEcore.getTypeLiteralCSAccess();
	}
	
	public ParserRule getTypeLiteralCSRule() {
		return getTypeLiteralCSAccess().getRule();
	}

	//TypeLiteralWithMultiplicityCS returns base::TypedRefCS:
	//	TypeLiteralCS multiplicity=MultiplicityCS?;
	public EssentialOCLGrammarAccess.TypeLiteralWithMultiplicityCSElements getTypeLiteralWithMultiplicityCSAccess() {
		return gaOCLinEcore.getTypeLiteralWithMultiplicityCSAccess();
	}
	
	public ParserRule getTypeLiteralWithMultiplicityCSRule() {
		return getTypeLiteralWithMultiplicityCSAccess().getRule();
	}

	//TypeLiteralExpCS:
	//	ownedType=TypeLiteralWithMultiplicityCS;
	public EssentialOCLGrammarAccess.TypeLiteralExpCSElements getTypeLiteralExpCSAccess() {
		return gaOCLinEcore.getTypeLiteralExpCSAccess();
	}
	
	public ParserRule getTypeLiteralExpCSRule() {
		return getTypeLiteralExpCSAccess().getRule();
	}

	//TypeNameExpCS:
	//	pathName=PathNameCS;
	public EssentialOCLGrammarAccess.TypeNameExpCSElements getTypeNameExpCSAccess() {
		return gaOCLinEcore.getTypeNameExpCSAccess();
	}
	
	public ParserRule getTypeNameExpCSRule() {
		return getTypeNameExpCSAccess().getRule();
	}

	//TypeExpCS returns base::TypedRefCS:
	//	(TypeNameExpCS | TypeLiteralCS) multiplicity=MultiplicityCS?;
	public EssentialOCLGrammarAccess.TypeExpCSElements getTypeExpCSAccess() {
		return gaOCLinEcore.getTypeExpCSAccess();
	}
	
	public ParserRule getTypeExpCSRule() {
		return getTypeExpCSAccess().getRule();
	}

	////---------------------------------------------------------------------
	// //  Expressions
	//
	////---------------------------------------------------------------------
	//
	//// An ExpCS permits a LetExpCS only in the final term to ensure
	//
	////  that let is right associative, whereas infix operators are left associative.
	//
	////   a = 64 / 16 / let b : Integer in 8 / let c : Integer in 4 
	// // is
	//
	////   a = (64 / 16) / (let b : Integer in 8 / (let c : Integer in 4 ))
	// ExpCS:
	//	PrefixedExpCS ({InfixExpCS.ownedExpression+=current} ownedOperator+=BinaryOperatorCS (ownedExpression+=PrefixedExpCS
	//	(ownedOperator+=BinaryOperatorCS ownedExpression+=PrefixedExpCS)* (ownedOperator+=BinaryOperatorCS
	//	ownedExpression+=LetExpCS)? | ownedExpression+=LetExpCS))? | {PrefixExpCS} ownedOperator+=UnaryOperatorCS+
	//	ownedExpression=LetExpCS | LetExpCS;
	public EssentialOCLGrammarAccess.ExpCSElements getExpCSAccess() {
		return gaOCLinEcore.getExpCSAccess();
	}
	
	public ParserRule getExpCSRule() {
		return getExpCSAccess().getRule();
	}

	//PrefixedExpCS returns ExpCS:
	//	{PrefixExpCS} ownedOperator+=UnaryOperatorCS+ ownedExpression=PrimaryExpCS | PrimaryExpCS;
	public EssentialOCLGrammarAccess.PrefixedExpCSElements getPrefixedExpCSAccess() {
		return gaOCLinEcore.getPrefixedExpCSAccess();
	}
	
	public ParserRule getPrefixedExpCSRule() {
		return getPrefixedExpCSAccess().getRule();
	}

	//PrimaryExpCS returns ExpCS:
	//	NestedExpCS | IfExpCS | SelfExpCS | PrimitiveLiteralExpCS | TupleLiteralExpCS | CollectionLiteralExpCS |
	//	TypeLiteralExpCS | {NameExpCS} pathName=PathNameCS ({IndexExpCS.nameExp=current} "[" firstIndexes+=ExpCS (","
	//	firstIndexes+=ExpCS)* "]" ("[" secondIndexes+=ExpCS ("," secondIndexes+=ExpCS)* "]")? (atPre?="@" "pre")? |
	//	{ConstructorExpCS.nameExp=current} "{" (ownedParts+=ConstructorPartCS ("," ownedParts+=ConstructorPartCS)* |
	//	value=StringLiteral) "}" | (atPre?="@" "pre")? ({InvocationExpCS.nameExp=current} "(" (argument+=NavigatingArgCS
	//	argument+=NavigatingCommaArgCS* (argument+=NavigatingSemiArgCS argument+=NavigatingCommaArgCS*)?
	//	(argument+=NavigatingBarArgCS argument+=NavigatingCommaArgCS*)?)? ")")?);
	public EssentialOCLGrammarAccess.PrimaryExpCSElements getPrimaryExpCSAccess() {
		return gaOCLinEcore.getPrimaryExpCSAccess();
	}
	
	public ParserRule getPrimaryExpCSRule() {
		return getPrimaryExpCSAccess().getRule();
	}

	//// Type-less init is an illegal infix expression
	// NavigatingArgCS:
	//	name=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" init=ExpCS)?)?;
	public EssentialOCLGrammarAccess.NavigatingArgCSElements getNavigatingArgCSAccess() {
		return gaOCLinEcore.getNavigatingArgCSAccess();
	}
	
	public ParserRule getNavigatingArgCSRule() {
		return getNavigatingArgCSAccess().getRule();
	}

	//// Type-less init is an illegal infix expression
	// NavigatingBarArgCS returns NavigatingArgCS:
	//	prefix="|" name=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" init=ExpCS)?)?;
	public EssentialOCLGrammarAccess.NavigatingBarArgCSElements getNavigatingBarArgCSAccess() {
		return gaOCLinEcore.getNavigatingBarArgCSAccess();
	}
	
	public ParserRule getNavigatingBarArgCSRule() {
		return getNavigatingBarArgCSAccess().getRule();
	}

	//// Type-less init is an illegal infix expression
	// NavigatingCommaArgCS returns NavigatingArgCS:
	//	prefix="," name=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" init=ExpCS)?)?;
	public EssentialOCLGrammarAccess.NavigatingCommaArgCSElements getNavigatingCommaArgCSAccess() {
		return gaOCLinEcore.getNavigatingCommaArgCSAccess();
	}
	
	public ParserRule getNavigatingCommaArgCSRule() {
		return getNavigatingCommaArgCSAccess().getRule();
	}

	//// Type-less init is an illegal infix expression
	// NavigatingSemiArgCS returns NavigatingArgCS:
	//	prefix=";" name=NavigatingArgExpCS (":" ownedType=TypeExpCS ("=" init=ExpCS)?)?;
	public EssentialOCLGrammarAccess.NavigatingSemiArgCSElements getNavigatingSemiArgCSAccess() {
		return gaOCLinEcore.getNavigatingSemiArgCSAccess();
	}
	
	public ParserRule getNavigatingSemiArgCSRule() {
		return getNavigatingSemiArgCSAccess().getRule();
	}

	//// Intended to be overridden
	// //	'?'	-- defined by Complete OCL
	// NavigatingArgExpCS returns ExpCS:
	//	ExpCS;
	public EssentialOCLGrammarAccess.NavigatingArgExpCSElements getNavigatingArgExpCSAccess() {
		return gaOCLinEcore.getNavigatingArgExpCSAccess();
	}
	
	public ParserRule getNavigatingArgExpCSRule() {
		return getNavigatingArgExpCSAccess().getRule();
	}

	//IfExpCS:
	//	"if" condition=ExpCS "then" thenExpression=ExpCS "else" elseExpression=ExpCS "endif";
	public EssentialOCLGrammarAccess.IfExpCSElements getIfExpCSAccess() {
		return gaOCLinEcore.getIfExpCSAccess();
	}
	
	public ParserRule getIfExpCSRule() {
		return getIfExpCSAccess().getRule();
	}

	//LetExpCS:
	//	"let" variable+=LetVariableCS ("," variable+=LetVariableCS)* "in" in=ExpCS;
	public EssentialOCLGrammarAccess.LetExpCSElements getLetExpCSAccess() {
		return gaOCLinEcore.getLetExpCSAccess();
	}
	
	public ParserRule getLetExpCSRule() {
		return getLetExpCSAccess().getRule();
	}

	//LetVariableCS:
	//	name=UnrestrictedName (":" ownedType=TypeExpCS)? "=" initExpression=ExpCS;
	public EssentialOCLGrammarAccess.LetVariableCSElements getLetVariableCSAccess() {
		return gaOCLinEcore.getLetVariableCSAccess();
	}
	
	public ParserRule getLetVariableCSRule() {
		return getLetVariableCSAccess().getRule();
	}

	//NestedExpCS:
	//	"(" source=ExpCS ")";
	public EssentialOCLGrammarAccess.NestedExpCSElements getNestedExpCSAccess() {
		return gaOCLinEcore.getNestedExpCSAccess();
	}
	
	public ParserRule getNestedExpCSRule() {
		return getNestedExpCSAccess().getRule();
	}

	//SelfExpCS:
	//	{SelfExpCS} "self";
	public EssentialOCLGrammarAccess.SelfExpCSElements getSelfExpCSAccess() {
		return gaOCLinEcore.getSelfExpCSAccess();
	}
	
	public ParserRule getSelfExpCSRule() {
		return getSelfExpCSAccess().getRule();
	}
}
